1a
n = int(input("Enter number of elements : "))  
# In[2]: 
print("Enter the inputs") 
inputs = [] # creating an empty list for inputs 
# iterating till the range  
for i in range(0, n):  
ele = float(input())  
inputs.append(ele) # adding the element  
print(inputs)  
# In[3]: 
print("Enter the weights") 
# creating an empty list for weights 
weights = []  
# iterating till the range  
for i in range(0, n):  
ele = float(input())  
weights.append(ele) # adding the element  
print(weights)  
# In[4]: 
print("The net input can be calculated as   Yin = x1w1 + x2w2 + x3w3") 
# In[5]: 
Yin = [] 
for i in range(0, n): 
Yin.append(inputs[i]*weights[i]) 
print(round(sum(Yin),3))

1b
n = int(input("Enter number of elements : "))  
print("Enter the inputs:") 
4 
inputs = [] # creating an empty list for inputs 
for i in range(0, n):  
ele = float(input())  
inputs.append(ele) # adding the element  
print(inputs)  
print("Enter the weights:") 
weights = []  
for i in range(0, n):  
ele = float(input())  
weights.append(ele) # adding the element  
print(weights)  
b=float(input("Enter bias value:")) 
print("The net input can be calculated as   Yin = b + x1w1 + x2w2:") 
Yin = [] 
for i in range(0, n): 
Yin.append(inputs[i]*weights[i]) 
print(round((sum(Yin)+b),3))


2a
num_ip = int(input("Enter the number of inputs : ")) 
#Set the weights with value 1 
w1 = 1 
w2 = 1 
print("For the ", num_ip , " inputs calculate the net input using yin = x1w1 + x2w2 ") 
x1 = [] 
x2 = [] 
for j in range(0, num_ip): 
ele1 = int(input("x1 = ")) 
ele2 = int(input("x2 = ")) 
x1.append(ele1) 
x2.append(ele2) 
print("x1 = ",x1) 
print("x2 = ",x2) 
n = x1 * w1 
m = x2 * w2 
Yin = [] 
for i in range(0, num_ip): 
Yin.append(n[i] + m[i]) 
print("Yin = ",Yin) 
#Assume one weight as excitatory and the other as inhibitory, i.e., 
Yin = [] 
for i in range(0, num_ip): 
Yin.append(n[i] - m[i]) 
print("After assuming one weight as excitatory and the other as inhibitory Yin = ",Yin) 
#From the calculated net inputs, now it is possible to fire the neuron for input (1, 0) 
#only by fixing a threshold of 1, i.e., θ ≥ 1 for Y unit.  
#Thus, w1 = 1, w2 = -1; θ ≥ 1 
Y=[] 
for i in range(0, num_ip): 
if(Yin[i]>=1): 
ele=  1 
Y.append(ele) 
if(Yin[i]<1): 
ele=  0 
8 
Y.append(ele) 
print("Y = ",Y)


2b
import numpy as np 
print('Enter weights') 
w11=int(input('Weight w11=')) 
w12=int(input('weight w12=')) 
w21=int(input('Weight w21=')) 
w22=int(input('weight w22=')) 
11 
v1=int(input('weight v1=')) 
v2=int(input('weight v2=')) 
print('Enter Threshold Value') 
theta=int(input('theta=')) 
x1=np.array([0, 0, 1, 1]) 
x2=np.array([0, 1, 0, 1]) 
z=np.array([0, 1, 1, 0]) 
con=1 
y1=np.zeros((4,)) 
y2=np.zeros((4,)) 
y=np.zeros((4,)) 
while con==1: 
zin1=np.zeros((4,)) 
zin2=np.zeros((4,)) 
zin1=x1*w11+x2*w21 
zin2=x1*w21+x2*w22 
print("z1",zin1) 
print("z2",zin2) 
for i in range(0,4): 
if zin1[i]>=theta: 
y1[i]=1 
else: 
y1[i]=0 
if zin2[i]>=theta: 
y2[i]=1 
else: 
y2[i]=0 
yin=np.array([]) 
yin=y1*v1+y2*v2 
12 
for i in range(0,4): 
if yin[i]>=theta: 
y[i]=1 
else: 
y[i]=0 
print("yin",yin) 
print('Output of Net') 
y=y.astype(int) 
print("y",y) 
print("z",z) 
if np.array_equal(y,z): 
con=0 
else: 
print("Net is not learning enter another set of weights and Threshold value") 
w11=input("Weight w11=") 
w12=input("weight w12=") 
w21=input("Weight w21=") 
w22=input("weight w22=") 
v1=input("weight v1=") 
v2=input("weight v2=") 
theta=input("theta=") 
print("McCulloch-Pitts Net for XOR function") 
print("Weights of Neuron Z1") 
print(w11) 
print(w21) 
print("weights of Neuron Z2") 
print(w12) 
13 
print(w22) 
print("weights of Neuron Y") 
print(v1) 
print(v2) 
print("Threshold value") 
print(theta)
