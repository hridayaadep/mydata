1a
n = int(input("Enter number of elements : "))  
# In[2]: 
print("Enter the inputs") 
inputs = [] # creating an empty list for inputs 
# iterating till the range  
for i in range(0, n):  
ele = float(input())  
inputs.append(ele) # adding the element  
print(inputs)  
# In[3]: 
print("Enter the weights") 
# creating an empty list for weights 
weights = []  
# iterating till the range  
for i in range(0, n):  
ele = float(input())  
weights.append(ele) # adding the element  
print(weights)  
# In[4]: 
print("The net input can be calculated as   Yin = x1w1 + x2w2 + x3w3") 
# In[5]: 
Yin = [] 
for i in range(0, n): 
Yin.append(inputs[i]*weights[i]) 
print(round(sum(Yin),3))

1b
n = int(input("Enter number of elements : "))  
print("Enter the inputs:") 
inputs = [] # creating an empty list for inputs 
for i in range(0, n):  
ele = float(input())  
inputs.append(ele) # adding the element  
print(inputs)  
print("Enter the weights:") 
weights = []  
for i in range(0, n):  
ele = float(input())  
weights.append(ele) # adding the element  
print(weights)  
b=float(input("Enter bias value:")) 
print("The net input can be calculated as   Yin = b + x1w1 + x2w2:") 
Yin = [] 
for i in range(0, n): 
Yin.append(inputs[i]*weights[i]) 
print(round((sum(Yin)+b),3))


2a
num_ip = int(input("Enter the number of inputs : ")) 
#Set the weights with value 1 
w1 = 1 
w2 = 1 
print("For the ", num_ip , " inputs calculate the net input using yin = x1w1 + x2w2 ") 
x1 = [] 
x2 = [] 
for j in range(0, num_ip): 
ele1 = int(input("x1 = ")) 
ele2 = int(input("x2 = ")) 
x1.append(ele1) 
x2.append(ele2) 
print("x1 = ",x1) 
print("x2 = ",x2) 
n = x1 * w1 
m = x2 * w2 
Yin = [] 
for i in range(0, num_ip): 
Yin.append(n[i] + m[i]) 
print("Yin = ",Yin) 
#Assume one weight as excitatory and the other as inhibitory, i.e., 
Yin = [] 
for i in range(0, num_ip): 
Yin.append(n[i] - m[i]) 
print("After assuming one weight as excitatory and the other as inhibitory Yin = ",Yin) 
#From the calculated net inputs, now it is possible to fire the neuron for input (1, 0) 
#only by fixing a threshold of 1, i.e., θ ≥ 1 for Y unit.  
#Thus, w1 = 1, w2 = -1; θ ≥ 1 
Y=[] 
for i in range(0, num_ip): 
if(Yin[i]>=1): 
ele=  1 
Y.append(ele) 
if(Yin[i]<1): 
ele=  0 
Y.append(ele) 
print("Y = ",Y)


2b
import numpy as np 
print('Enter weights') 
w11=int(input('Weight w11=')) 
w12=int(input('weight w12=')) 
w21=int(input('Weight w21=')) 
w22=int(input('weight w22=')) 
v1=int(input('weight v1=')) 
v2=int(input('weight v2=')) 
print('Enter Threshold Value') 
theta=int(input('theta=')) 
x1=np.array([0, 0, 1, 1]) 
x2=np.array([0, 1, 0, 1]) 
z=np.array([0, 1, 1, 0]) 
con=1 
y1=np.zeros((4,)) 
y2=np.zeros((4,)) 
y=np.zeros((4,)) 
while con==1: 
zin1=np.zeros((4,)) 
zin2=np.zeros((4,)) 
zin1=x1*w11+x2*w21 
zin2=x1*w21+x2*w22 
print("z1",zin1) 
print("z2",zin2) 
for i in range(0,4): 
if zin1[i]>=theta: 
y1[i]=1 
else: 
y1[i]=0 
if zin2[i]>=theta: 
y2[i]=1 
else: 
y2[i]=0 
yin=np.array([]) 
yin=y1*v1+y2*v2 
for i in range(0,4): 
if yin[i]>=theta: 
y[i]=1 
else: 
y[i]=0 
print("yin",yin) 
print('Output of Net') 
y=y.astype(int) 
print("y",y) 
print("z",z) 
if np.array_equal(y,z): 
con=0 
else: 
print("Net is not learning enter another set of weights and Threshold value") 
w11=input("Weight w11=") 
w12=input("weight w12=") 
w21=input("Weight w21=") 
w22=input("weight w22=") 
v1=input("weight v1=") 
v2=input("weight v2=") 
theta=input("theta=") 
print("McCulloch-Pitts Net for XOR function") 
print("Weights of Neuron Z1") 
print(w11) 
print(w21) 
print("weights of Neuron Z2") 
print(w12) 
print(w22) 
print("weights of Neuron Y") 
print(v1) 
print(v2) 
print("Threshold value") 
print(theta)


3a
import numpy as np 
#first pattern 
x1=np.array([1,1,1,-1,1,-1,1,1,1]) 
#second pattern 
x2=np.array([1,1,1,1,-1,1,1,1,1]) 
#initialize bais value 
b=0 
#define target 
y=np.array([1,-1]) 
wtold=np.zeros((9,)) 
wtnew=np.zeros((9,)) 
wtnew=wtnew.astype(int) 
wtold=wtold.astype(int) 
bais=0 
print("First input with target =1") 
for i in range(0,9): 
wtold[i]=wtold[i]+x1[i]*y[0] 
wtnew=wtold 
b=b+y[0] 
print("new wt =", wtnew) 
print("Bias value",b) 
print("Second input with target =-1") 
for i in range(0,9): 
wtnew[i]=wtold[i]+x2[i]*y[1] 
b=b+y[1] 
print("new wt =", wtnew) 
print("Bias value",b)


3b
#supervised learning 
import numpy as np 
import time 
np.set_printoptions(precision=2) 
x=np.zeros((3,)) 
weights=np.zeros((3,)) 
desired=np.zeros((3,)) 
actual=np.zeros((3,)) 
for i in range(0,3): 
x[i]=float(input("Initial inputs:")) 
for i in range(0,3): 
weights[i]=float(input("Initial weights:")) 
for i in range(0,3): 
desired[i]=float(input("Desired output:")) 
a=float(input("Enter learning rate:")) 
actual=x*weights 
print("actual",actual) 
print("desired",desired)  
while True: 
if np.array_equal(desired,actual): 
break    #no change 
else: 
for i in range(0,3): 
weights[i]=weights[i]+a*(desired[i]-actual[i]) 
actual=x*weights    
print("weights",weights) 
print("actual",actual) 
print("desired",desired) 
print("*"*30) 
print("Final output") 
print("Corrected weights",weights) 
print("actual",actual) 
print("desired",desired)


8a
def overlapping(list1,list2):  
c=0 
d=0 
for i in list1:  
c+=1 
for i in list2:  
d+=1 
for i in range(0,c):  
for j in range(0,d):  
if(list1[i]==list2[j]):  
return 1 
return 0 
list1=[1,2,3,4,5]  
list2=[6,7,8,9]  
if(overlapping(list1,list2)):  
print("overlapping")  
else:  
print("not overlapping")


8b
x = 5 
if (type(x) is int):  
print ("true")  
else:  
print ("false")


9a
pip install fuzzywuzzy 
# Python code showing all the ratios together,  
# make sure you have installed fuzzywuzzy module  
from fuzzywuzzy import fuzz  
from fuzzywuzzy import process  
s1 = "I love fuzzysforfuzzys" 
s2 = "I am loving fuzzysforfuzzys" 
print ("FuzzyWuzzy Ratio:", fuzz.ratio(s1, s2))  
print ("FuzzyWuzzyPartialRatio: ", fuzz.partial_ratio(s1, s2))  
print ("FuzzyWuzzyTokenSortRatio: ", fuzz.token_sort_ratio(s1, s2))  
print ("FuzzyWuzzyTokenSetRatio: ", fuzz.token_set_ratio(s1, s2))  
print ("FuzzyWuzzyWRatio: ", fuzz.WRatio(s1, s2),'\n\n') 
# for process library,  
query = 'fuzzys for fuzzys' 
choices = ['fuzzy for fuzzy', 'fuzzy fuzzy', 'g. for fuzzys']  
print ("List of ratios: ") 
print (process.extract(query, choices), '\n') 
print ("Best among the above list: ",process.extractOne(query, choices)) 


9b
import numpy as np 
import skfuzzy as fuzz 
from skfuzzy import control as ctrl 
quality = ctrl.Antecedent(np.arange(0, 11, 1), 'quality') 
service = ctrl.Antecedent(np.arange(0, 11, 1), 'service') 
tip = ctrl.Consequent(np.arange(0, 26, 1), 'tip') 
quality.automf(3) 
service.automf(3) 
tip['low'] = fuzz.trimf(tip.universe, [0, 0, 13]) 
tip['medium'] = fuzz.trimf(tip.universe, [0, 13, 25]) 
tip['high'] = fuzz.trimf(tip.universe, [13, 25, 25]) 
quality['average'].view() 
service.view() 
tip.view() 
rule1 = ctrl.Rule(quality['poor'] | service['poor'], tip['low']) 
rule2 = ctrl.Rule(service['average'], tip['medium']) 
rule3 = ctrl.Rule(service['good'] | quality['good'], tip['high']) 
rule1.view() 
tipping_ctrl = ctrl.ControlSystem([rule1, rule2, rule3]) 
tipping = ctrl.ControlSystemSimulation(tipping_ctrl) 
# Pass inputs to the ControlSystem using Antecedent labels with Pythonic API 
tipping.input['quality'] = 6.5 
tipping.input['service'] = 9.8 
# Crunch the numbers 
tipping.compute() 
print tipping.output['tip'] 
tip.view(sim=tipping)
